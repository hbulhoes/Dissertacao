% !TeX spellcheck = <none>
%!TEX root = Projeto.tex

\section{API de ocultação do DOM fundamentada em Shadow DOM}

Com base no isolamento de árvores de DOM proporcionado pelo recurso de \poe{shadow DOM}, descrito preliminarmente em \ref{Section: introShadowDOM}, é possível explorar o comportamento derivado de uma propriedade das APIs que estabelece, em sua especificação, que para todo \poe{shadow host} será determinada a visibilidade de sua \poe{shadow tree}. O conceito de \textit{visibilidade}, neste contexto, corresponde à possibilidade de que {\scripts} consigam alcançar nós do DOM contidos na \poe{shadow tree}, tanto indiretamente, enumerando os nós-filhos da árvore por meio da propriedade |ShadowRoot.childNodes|, quanto diretamente, por meio de métodos como |getElementById()| ou |querySelector()|, implementados por objetos como |Element|, |HTMLDocument| e |DocumentFragment|.

O atributo de visibilidade é determinado no momento da criação do \poe{shadow host}. A listagem de código \ref{Src: jsShadowHostCtor}, entre as linhas 2 e 6, exemplifica os efeitos mais evidentes desse atributo. Essencialmente, os {\scripts} ganham ou perdem acesso à propriedade |Element.shadowRoot|, na medida em que o parâmetro |mode| é determinado como |open| ou |closed|.

\lstinputlisting[language=JavaScript,
	inputencoding=utf8,
	label={Src: jsShadowHostCtor},
	caption={Determinação da visibilidade da \poe{shadow tree} e sua consequência na tentativa de acesso ao DOM subjacente}]
	{codigo/sample04-shadow-host-ctor.js}

Tornando inacessível a propriedade |Element.shadowRoot|, o método |Element.attachShadow({mode:'closed'})| provê um meio programático para a definição de regiões protegidas na estrutura DOM da página web. No entanto, a inacessibilidade do conteúdo da \poe{shadow root} depende de medidas que vão além das garantias previstas pela especificação da API de Shadow DOM. Isso se deve à extensibilidade da linguagem Javascript, que permite que {\scripts} interceptem quaisquer métodos de qualquer API. Desse modo, um {\script} cuidadosamente escrito poderia ganhar acesso a todas as \poe{shadow roots} criadas em uma página web, independentemente da opção |open| ou |closed| atribuída ao parâmetro |mode| em |attachShadow()|. Essa estratégia é detalhada na seção seguinte. %exemplificada na listagem de código \ref{Src: jsShadowApiIntercept}.

\subsection{Interceptação de métodos nativos do ambiente de execução}

A linguagem Javascript apresenta \textit{herança prototípica} como mecanismo para compartilhar estrutura, comportamento e estado entre os objetos que participam de um mesmo relacionamento denominado de \textit{cadeia prototípica}. Por esse mecanismo, a linguagem Javascript admite o uso de abstrações de classes, a exemplo de linguagens estáticas como Java e C++ \cite{ECMA2017}. Porém, ao contrário dessas linguagens, Javascript possibilita a redefinição dinâmica dos membros dos protótipos/classes. A listagem \ref{Src: jsPrototypicalInheritance} exemplifica esse mecanismo.

%Objetos em Javascript são entidades de estrutura dinâmica, comportando-se como dicionários ou \poe{hashes} de informação. Por meio de herança prototípica, objetos em Javascript são definidos como uma composição formada tanto pelos atributos herdados da cadeia de protótipos quanto dos atributos associados diretamente ao objeto.

\lstinputlisting[language=JavaScript,
	inputencoding=utf8,
	label={Src: jsPrototypicalInheritance},
	caption={Demonstração de herança prototípica em Javascript}]
	{codigo/sample05-prototype.js}

Uma consequência da flexibilidade oferecida pela herança prototípica é que um {\script} pode modificar os métodos de um protótipo de forma que o acionamento desses métodos seja encapsulado por código arbitrário. Essa capacidade de interceptação permite que métodos sejam instrumentados, monitorados ou corrompidos para quaisquer fins. O exemplo na listagem \ref{Src: jsMethodHijacking} demonstra como o método |Number.toString()| pode ser desvirtuado para retornar informação incorreta -- neste caso, o método sempre retornará a mesma \poe{string}, ``42''.

\lstinputlisting[language=JavaScript,
	inputencoding=utf8,
	label={Src: jsMethodHijacking},
	caption={Exemplo de método nativo interceptado por um script}]
	{codigo/sample06-hijack.js}

\citeinline{Magazinius2012}, em seu estudo sobre a efetividade das estratégias empregadas por \poe{sandboxes} como Google Caja e Facebook Javascript, denomina a manipulação mal-intencionada da cadeia de herança como ``envenenamento do protótipo'' (\poe{prototype poisoning}, no artigo original).